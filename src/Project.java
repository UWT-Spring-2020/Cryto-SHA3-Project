package source;
  
import java.math.BigInteger;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.lang.Cloneable;

class Project {

    public static void main(String[] args) {
        System.out.println("Hello World! from Crypto Project");

        // Part 1
    //    cSHAKE256(public_key, 256, "", "key fingerprint");
    //    cSHAKE128(email_contents, 256, "", "email signature");

       // more, sample codes to illustrate the use of SHA-512
       System.out.println("HashCode Generated by SHA-512 for: ");
  
        String s1 = "GeeksForGeeks";
        System.out.println("\n" + s1 + " : " + encryptThisString(s1));
  
        String s2 = "hello world";
        System.out.println("\n" + s2 + " : " + encryptThisString(s2));

       // Part 2
    }

    // Java program to calculate SHA-512 hash value

  

    public static String encryptThisString(String input)
    {
        try {
            // getInstance() method is called with algorithm SHA-512
            MessageDigest md = MessageDigest.getInstance("SHA-512");
  
            // digest() method is called
            // to calculate message digest of the input string
            // returned as array of byte
            byte[] messageDigest = md.digest(input.getBytes());

            System.out.println("Message Digest:\n" + messageDigest + "\n");
  
            // Convert byte array into signum representation
            BigInteger no = new BigInteger(1, messageDigest);

            System.out.println("Big Integer:\n" + no + "\n");
  
            // Convert message digest into hex value
            String hashtext = no.toString(16);

            System.out.println("Hash Text:\n" + hashtext + "\n");
  
            // Add preceding 0s to make it 32 bit
            while (hashtext.length() < 32) {
                hashtext = "0" + hashtext;
            }

            System.out.println("Outval:\n" + hashtext + "\n");
  
            // return the HashText
            return hashtext;
        }
  
        // For specifying wrong message digest algorithms
        catch (NoSuchAlgorithmException e) {
            throw new RuntimeException(e);
        }
    }

  
    /**
     * KMACXOF256(K, X, L, S):
     * Validity Conditions: len(K) < 2^2040 and 0 <= L  and len(S) < 2^2040
     *
     * @param K key bit string.
     * @param X input bit string.
     * @param L output length
     * @param S customization string
     */
    public static byte[] KMACXOF256_KECCAK(String K, String X, int L, String S) {

        byte[] newX = bytepad(concat(encode_string(K), 136, X.getBytes(), right_encode(0)));
        byte[] T = bytepad(encode_string("KMAC") + encode_string(S), 136);
        // return KECCAK[512](T + newX + 00, L);

        return KECCAK(T + newX + 00, L);
    }


    /**
     * KMACXOF256(K, X, L, S):
     * Validity Conditions: len(K) < 2^2040 and 0 <= L  and len(S) < 2^2040
     *
     * @param K key bit string.
     * @param X input bit string.
     * @param L output length
     * @param S customization string
     */
    public static byte[] KMACXOF256_cSHAKE(String K, String X, int L, String S) {

        byte[] newX = bytepad(encode_string(K), 136) + X.getBytes() + right_encode(0);
        return cSHAKE256(newX, L, "KMAC", S);

    }

    /**
     * cSHAKE256(X, L, N, S):
     * Validity Conditions: len(N) < 2^2040 and len(S) < 2^2040
     *
     * @param X input bit string
     * @param L output length
     * @param N function-name bit string
     * @param S customization bit string
     */
    public static byte[] cSHAKE256(String X, int L, String N, String S) {

        if (N.equals("") && S.equal("")) {
            return SHAKE256(X,L);
        } else {
            // return KECCAK[512](bytepad(encode_string(N) + encode_string(S), 136) + X.getBytes() + 00, L);
            return KECCAK(bytepad(encode_string(N) + encode_string(S), 136) + X.getBytes() + 00, L);
        }
    }


    /**
     * bytepad(X, w):
     * Validity Conditions: w > 0
     *
     * @param X
     * @param w
     */
    public static byte[] bytepad(int X, int w) {

        byte[] z = left_encode(w) + X;
        while (z.length % 8 != 0)
            z = z + 0;
        while ((z.length/8) % w != 0)
            z = z + 00000000;
        return z;
    }
    /** 
     *    encode_string(S):
     *    Validity Conditions: 0 <= len(S) < 2^2040
     *
     *    @param S    
    */
    public static byte[] encode_string(String S) {

            return left_encode(len(S)) + S.getBytes();

    }

     /**
     *   left_encode(x):
     *   Validity Conditions: 0 <= x < 2^2040
     *
     *   @param X string length
     *
     */
    public static byte[] left_encode(int X) {
        
        //        Let n be the smallest positive integer for which 2 ^ 8n > x
        //        Let x1, x2, ..., xn be the base-256 encoding of x satisfying:
        //        x = (Rheiman Sum) 2^8(n - i) xi, for i = 1 to n
        //        Let Oi = enc8(xi), i = 1 to n
        //        Let O0 = enc8(n)
        //        Return O = O0 || Oi || ... || On-1 || On

        byte n = 1;

        long v = X;
        while ((v >>= 8) != 0)
            n++;

        byte[] b = new byte[n + 1];

        b[0] = n;

        for (int i = 1; i <= n; i++)
            b[i] = (byte)(X >> (8 * (n - i)));

        return b;
    }

    /**
    *   right_encode(x):
    *   Validity Conditions: 0 <= x < 2^2040
    *
    *  @param X string length
    *
    */
    public static byte[] right_encode(int X) {
        
        //        Let n be the smallest positive integer for which 2^8n > x
        //        Let x1, x2, ..., xn be the base-256 encoding of x satisfying:
        //        x = (Rheiman Sum) 2^8(n-1) xi, for i = 1 to n
        //        Let Oi = enc8(x1), for i = 1 to n
        //        Let On+1 = enc8(n)
        //        Return O = O1 || O2 || ... || On || On+1

        byte n = 1;

        long v = X;
        while ((v >>= 8) != 0)
            n++;

        byte[] b = new byte[n + 1];

        b[n] = n;

        for (int i = 0; i < n; i++)
            b[i] = (byte)(X >> (8 * (n - i - 1)));

        return b;
    }

//        # KECCAK ?? Import from java.lang.Cloneable
    public static byte[] KECCAK(byte[] input, int length) {
        if (length = 512){
            Keccak.DigestKeccak kecc = new Keccak.Digest512();
            kecc.update(input, 0, length);
            return kecc.digest;
        }
        return null;
    }
    
}